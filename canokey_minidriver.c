/*
 * CanoKey Smart Card Minidriver
 *
 * This file implements a smart card minidriver for CanoKey
 * based on the Windows Smart Card Minidriver specification.
 */

#include "cardmod.h"
#include "logging.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>
#include <winscard.h>

// Global function pointers for data caching mechanisms
PFN_CSP_CACHE_ADD_FILE g_pfnCspCacheAddFile = NULL;
PFN_CSP_CACHE_LOOKUP_FILE g_pfnCspCacheLookupFile = NULL;
PFN_CSP_CACHE_DELETE_FILE g_pfnCspCacheDeleteFile = NULL;

// Global function pointers for memory management
PFN_CSP_ALLOC g_pfnCspAlloc = NULL;
PFN_CSP_REALLOC g_pfnCspReAlloc = NULL;
PFN_CSP_FREE g_pfnCspFree = NULL;

// Global function pointer for padding removal
PFN_CSP_UNPAD_DATA g_pfnCspUnpadData = NULL;

static void init_logging_file(int level) {
  CreateDirectory("C:\\Logs", NULL); // ignore errors
  char log_file_name[64], time[16];
  SYSTEMTIME st;
  GetLocalTime(&st);
  sprintf_s(time, sizeof(time), "%04d%02d%02d_%02d%02d%02d", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute,
            st.wSecond);
  sprintf_s(log_file_name, sizeof(log_file_name), "C:\\Logs\\canokey_minidriver_%s_%d.log", time,
            (int32_t)GetCurrentProcessId());
  cmd_init_logging(log_file_name, level);
  CMD_INFO("Start logging to file %s...\n", log_file_name);
}

// DllMain function
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
  switch (fdwReason) {
  case DLL_PROCESS_ATTACH:
    // Initialize the DLL
    init_logging_file(CMD_LOG_LEVEL_DEBUG);
    CMD_INFO("CanoKey Smart Card Minidriver compiled at %s %s\n", __DATE__, __TIME__);
    CMD_INFO("DLL loaded with handle %p\n", hinstDLL);
    FUNC_TRACE(DisableThreadLibraryCalls(hinstDLL));
    break;
  case DLL_PROCESS_DETACH:
    // Clean up resources
    CMD_INFO("DLL unloaded with handle %p, stop logging...\n", hinstDLL);
    CMD_INFO("========================================\n");
    cmd_stop_logging();
    break;
  case DLL_THREAD_ATTACH:
  case DLL_THREAD_DETACH:
    // No action needed
    break;
  }
  return TRUE;
}

// clang-format off
// This is the list of functions required by the spec
// that we **do not want** to support.
// Please make sure any function is either listed here
// or has a concrete definition. Otherwise this mini driver
// would be silently ignored by CSP.
#define INVOKE_X_ON_NO_IMPL_FUNCS(X) \
X(CardDeleteContainer) \
X(CardCreateContainer) \
X(CardGetChallenge) \
X(CardAuthenticateChallenge) \
X(CardUnblockPin) \
X(CardChangeAuthenticator) \
X(CardDeauthenticate) \
X(CardCreateDirectory) \
X(CardDeleteDirectory) \
X(CardCreateFile) \
X(CardWriteFile) \
X(CardDeleteFile) \
X(CardSetContainerProperty) \
X(CardRSADecrypt) \
X(CardConstructDHAgreement) \
X(CardDeriveKey) \
X(CardDestroyDHAgreement) \
X(CardGetChallengeEx) \
X(CardChangeAuthenticatorEx) \
X(MDImportSessionKey) \
X(MDEncryptData) \
X(CardImportSessionKey) \
X(CardGetSharedKeyHandle) \
X(CardGetAlgorithmProperty) \
X(CardGetKeyProperty) \
X(CardSetKeyProperty) \
X(CardDestroyKey) \
X(CardProcessEncryptedData) \
X(CardCreateContainerEx)

#define CMD_NO_IMPL_FUNC_NAME(NAME) __cmd_noimpl__ ## NAME
#define CMD_GEN_NO_IMPL_FUNC(NAME) DWORD WINAPI CMD_NO_IMPL_FUNC_NAME(NAME)(__inout PCARD_DATA pCardData, ...) { \
  CMD_ERROR(#NAME " is not meant to be supported but called with pCardData %p\n", pCardData); \
  CMD_RETURN(SCARD_E_UNSUPPORTED_FEATURE, "not meant to be supported (generated by macro)"); \
}
INVOKE_X_ON_NO_IMPL_FUNCS(CMD_GEN_NO_IMPL_FUNC);
#undef CMD_GEN_NO_IMPL_FUNC
// clang-format on

/*
 * Function: CardAcquireContext
 *
 * Purpose: Initialize the CARD_DATA structure which will be used by
 *          the CSP to interact with a specific card.
 */
DWORD WINAPI CardAcquireContext(__inout PCARD_DATA pCardData, __in DWORD dwFlags) {
  DWORD dwReturn = 0;

  CMD_DEBUG("CardAcquireContext called with pCardData %p, dwFlags %x\n", pCardData, dwFlags);
  // TODO: add function to print internal structure of CARD_DATA?

  // Check if pCardData is valid
  if (!pCardData) {
    CMD_RETURN(ERROR_INVALID_PARAMETER, "pCardData is NULL");
  }

  if (dwFlags & CARD_SECURE_KEY_INJECTION_NO_CARD_MODE) {
    // This flag is not supported
    CMD_RETURN(SCARD_E_INVALID_PARAMETER, "CARD_SECURE_KEY_INJECTION_NO_CARD_MODE");
  }

  // Check version
  if (pCardData->dwVersion < CARD_DATA_VERSION_FOUR) {
    CMD_RETURN(ERROR_REVISION_MISMATCH, "dwVersion too old");
  }
  CMD_DEBUG("dwVersion %d\n", pCardData->dwVersion);

  if (!pCardData->hSCardCtx || !pCardData->hScard) {
    CMD_RETURN(SCARD_E_INVALID_HANDLE, "No hSCardCtx or hScard");
  }

  CMD_DEBUG("hScardCtx %p, hScard %p\n", pCardData->hSCardCtx, pCardData->hScard);

  if (!pCardData->pfnCspAlloc || !pCardData->pfnCspReAlloc || !pCardData->pfnCspFree) {
    CMD_RETURN(ERROR_INVALID_PARAMETER, "No pfnCsp* allocators");
  }

  if (!pCardData->pbAtr || pCardData->cbAtr == 0) {
    CMD_RETURN(ERROR_INVALID_PARAMETER, "No pbAtr or cbAtr");
  }

  if (!pCardData->pwszCardName) {
    CMD_RETURN(ERROR_INVALID_PARAMETER, "No pwszCardName");
  }

  // TODO: check pbAtr content

  // Import the data caching functions
  g_pfnCspCacheAddFile = pCardData->pfnCspCacheAddFile;
  g_pfnCspCacheLookupFile = pCardData->pfnCspCacheLookupFile;
  g_pfnCspCacheDeleteFile = pCardData->pfnCspCacheDeleteFile;

  // Import the memory management functions
  g_pfnCspAlloc = pCardData->pfnCspAlloc;
  g_pfnCspReAlloc = pCardData->pfnCspReAlloc;
  g_pfnCspFree = pCardData->pfnCspFree;

  // Import the padding removal function
  if (pCardData->dwVersion >= CARD_DATA_VERSION_SEVEN) {
    g_pfnCspUnpadData = pCardData->pfnCspUnpadData;
  }

  // Set function pointers in pCardData
  pCardData->pfnCardDeleteContext = CardDeleteContext;         // Yes
  pCardData->pfnCardQueryCapabilities = CardQueryCapabilities; // Yes
  pCardData->pfnCardDeleteContainer = NULL;                    // No
  pCardData->pfnCardCreateContainer = NULL;                    // No
  pCardData->pfnCardGetContainerInfo = CardGetContainerInfo;   // Yes
  pCardData->pfnCardAuthenticatePin = CardAuthenticatePin;     // Yes
  pCardData->pfnCardGetChallenge = NULL;                       // No (opt)
  pCardData->pfnCardAuthenticateChallenge = NULL;              // No (opt)
  pCardData->pfnCardUnblockPin = NULL;                         // No (opt)
  pCardData->pfnCardChangeAuthenticator = NULL;                // No (opt)
  pCardData->pfnCardDeauthenticate = NULL;                     // Yes (opt)
  pCardData->pfnCardCreateDirectory = NULL;                    // No
  pCardData->pfnCardDeleteDirectory = NULL;                    // No
  pCardData->pfnCardCreateFile = NULL;                         // No
  pCardData->pfnCardReadFile = CardReadFile;                   // Yes
  pCardData->pfnCardWriteFile = NULL;                          // No
  pCardData->pfnCardDeleteFile = NULL;                         // No
  pCardData->pfnCardEnumFiles = CardEnumFiles;                 // Yes
  pCardData->pfnCardGetFileInfo = CardGetFileInfo;             // Yes
  pCardData->pfnCardQueryFreeSpace = CardQueryFreeSpace;       // Yes
  pCardData->pfnCardQueryKeySizes = CardQueryKeySizes;         // Yes

  pCardData->pfnCardSignData = CardSignData;     // Yes
  pCardData->pfnCardRSADecrypt = NULL;           // Yes (opt)
  pCardData->pfnCardConstructDHAgreement = NULL; // Yes (opt)

  // New functions in version five.
  pCardData->pfnCardDeriveKey = NULL;          // Yes (opt)
  pCardData->pfnCardDestroyDHAgreement = NULL; // Yes (opt)
  // pCardData->pfnCspGetDHAgreement;

  // version 6 additions below here
  pCardData->pfnCardGetChallengeEx = NULL;                           // No (opt)
  pCardData->pfnCardAuthenticateEx = CardAuthenticateEx;             // Yes
  pCardData->pfnCardChangeAuthenticatorEx = NULL;                    // No (opt)
  pCardData->pfnCardDeauthenticateEx = CardDeauthenticateEx;         // Yes
  pCardData->pfnCardGetContainerProperty = CardGetContainerProperty; // Yes
  pCardData->pfnCardSetContainerProperty = NULL;                     // No
  pCardData->pfnCardGetProperty = CardGetProperty;                   // Yes
  pCardData->pfnCardSetProperty = CardSetProperty;                   // Yes

  // version 7 additions below here
  // pCardData->pfnCspUnpadData;
  pCardData->pfnMDImportSessionKey = NULL;       // No (opt)
  pCardData->pfnMDEncryptData = NULL;            // No (opt)
  pCardData->pfnCardImportSessionKey = NULL;     // No (opt)
  pCardData->pfnCardGetSharedKeyHandle = NULL;   // No (opt)
  pCardData->pfnCardGetAlgorithmProperty = NULL; // No (opt)
  pCardData->pfnCardGetKeyProperty = NULL;       // No (opt)
  pCardData->pfnCardSetKeyProperty = NULL;       // No (opt)
  pCardData->pfnCardDestroyKey = NULL;           // No (opt)
  pCardData->pfnCardProcessEncryptedData = NULL; // No (opt)
  pCardData->pfnCardCreateContainerEx = NULL;    // No (opt)

  // fill in generated stubs
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wcompare-distinct-pointer-types"

  // clang-format off
#define CMD_SET_CARD_DATA_PFN(NAME) do { \
  if (pCardData->pfn##NAME != NULL) { \
    CMD_ERROR("pCardData->pfn%s (set to %p) overridden by generated stub\n", #NAME, pCardData->pfn##NAME); \
  } \
  pCardData->pfn##NAME = (void *) CMD_NO_IMPL_FUNC_NAME(NAME); \
} while (0);
INVOKE_X_ON_NO_IMPL_FUNCS(CMD_SET_CARD_DATA_PFN);
#undef CMD_SET_CARD_DATA_PFN
#undef CMD_NO_IMPL_FUNC_NAME
  // clang-format on

  // check whether pCardData is fully filled
  uintptr_t *begin = (uintptr_t *)&pCardData->pfnCardDeleteContext;
  uintptr_t *end = (uintptr_t *)&pCardData->pfnCardCreateContainerEx;
  for (uintptr_t *p = begin; p <= end; p++) {
    if (*p == 0 && !(p == &pCardData->pvUnused3 || p == &pCardData->pvUnused4 ||
                     p == &pCardData->pfnCspGetDHAgreement || p == &pCardData->pfnCspUnpadData)) {
      CMD_ERROR("pCardData has NULL entry point at offset %lld to pfnCardDeleteContext, check CardAcquireContext!\n",
                p - begin);
    }
  }

#pragma clang diagnostic pop

  CMD_RET_OK;
}

#undef INVOKE_X_ON_NO_IMPL_FUNCS

/*
 * Function: CardDeleteContext
 *
 * Purpose: Free resources consumed by the CARD_DATA structure.
 */
DWORD WINAPI CardDeleteContext(__inout PCARD_DATA pCardData) {
  CMD_DEBUG("CardDeleteContext called with pCardData %p\n", pCardData);
  if (!pCardData) {
    CMD_RETURN(ERROR_INVALID_PARAMETER, "pCardData is NULL");
  }

  // Free vendor specific data
  if (pCardData->pvVendorSpecific) {
    pCardData->pfnCspFree(pCardData->pvVendorSpecific);
    pCardData->pvVendorSpecific = NULL;
  }

  CMD_RET_OK;
}

#define CMD_CHECK_DW_FLAGS                                                                                             \
  if (dwFlags != 0) {                                                                                                  \
    CMD_RETURN(ERROR_INVALID_PARAMETER, "dwFlags is not zero");                                                        \
  }

/*
 * Function: CardGetProperty
 *
 * Purpose: Get card properties.
 */
DWORD WINAPI CardGetProperty(__in PCARD_DATA pCardData, __in LPCWSTR wszProperty,
                             __out_bcount_part_opt(cbData, *pdwDataLen) PBYTE pbData, __in DWORD cbData,
                             __out PDWORD pdwDataLen, __in DWORD dwFlags) {
  CMD_DEBUG("CardGetProperty called with pCardData: %p, wszProperty: %S, pbData: %p, cbData: %d, pdwDataLen: %p, "
            "dwFlags: %x\n",
            pCardData, wszProperty, pbData, cbData, pdwDataLen, dwFlags);

  // TODO: Check pointers and maybe add locks

  if (wcscmp(wszProperty, CP_CARD_FREE_SPACE) == 0) {
    // Card free space property
    CMD_CHECK_DW_FLAGS;

    CMD_RET_UNIMPL;
  } else if (wcscmp(wszProperty, CP_CARD_CAPABILITIES) == 0) {
    // Card capabilities property
    CMD_CHECK_DW_FLAGS;

    if (cbData < sizeof(CARD_CAPABILITIES)) {
      CMD_RETURN(ERROR_INSUFFICIENT_BUFFER, "cbData is too small");
    }

    PCARD_CAPABILITIES pCardCapabilities = (PCARD_CAPABILITIES)pbData;
    pCardCapabilities->dwVersion = CARD_CAPABILITIES_CURRENT_VERSION;
    pCardCapabilities->fCertificateCompression = TRUE;
    pCardCapabilities->fKeyGen = FALSE; // TODO

    *pdwDataLen = sizeof(CARD_CAPABILITIES);

    DebugBreak();

    CMD_RET_OK;
  } else if (wcscmp(wszProperty, CP_CARD_KEYSIZES) == 0) {
    // Card key sizes property
    CMD_RET_UNIMPL;
  } else if (wcscmp(wszProperty, CP_CARD_READ_ONLY) == 0) {
    // Card read-only property
    CMD_CHECK_DW_FLAGS;

    *pdwDataLen = sizeof(BOOL);
    if (cbData < sizeof(BOOL)) {
      CMD_RETURN(ERROR_INSUFFICIENT_BUFFER, "cbData is too small");
    }
    *(BOOL *)pbData = TRUE; // TODO
    CMD_RET_OK;
  } else if (wcscmp(wszProperty, CP_CARD_CACHE_MODE) == 0) {
    // Card cache mode property
    CMD_CHECK_DW_FLAGS;

    *pdwDataLen = sizeof(DWORD);
    if (cbData < sizeof(DWORD)) {
      CMD_RETURN(ERROR_INSUFFICIENT_BUFFER, "cbData is too small");
    }
    *(DWORD *)pbData = CP_CACHE_MODE_NO_CACHE;
    CMD_RET_OK;
  } else if (wcscmp(wszProperty, CP_SUPPORTS_WIN_X509_ENROLLMENT) == 0) {
    // Support for Windows x.509 enrollment
    CMD_CHECK_DW_FLAGS;

    *pdwDataLen = sizeof(BOOL);
    if (cbData < sizeof(BOOL)) {
      CMD_RETURN(ERROR_INSUFFICIENT_BUFFER, "cbData is too small");
    }
    *(BOOL *)pbData = FALSE;
    CMD_RET_OK;
  } else if (wcscmp(wszProperty, CP_CARD_GUID) == 0) {
    // Card GUID - TODO should be the same as cardid, currently a placeholder
    CMD_CHECK_DW_FLAGS;

    BYTE cardGuid[16] = {0};
    *pdwDataLen = sizeof(cardGuid);
    if (cbData < sizeof(cardGuid)) {
      CMD_RETURN(ERROR_INSUFFICIENT_BUFFER, "cbData is too small");
    }
    memcpy(pbData, cardGuid, sizeof(cardGuid));
    CMD_RET_OK;
  } else if (wcscmp(wszProperty, CP_CARD_SERIAL_NO) == 0) {
    // Card serial number property
    CMD_CHECK_DW_FLAGS;

    CMD_RET_UNIMPL;
  } else if (wcscmp(wszProperty, CP_CARD_PIN_INFO) == 0) {
    // Card PIN info property
    PPIN_INFO p = (PPIN_INFO)pbData;

    if (cbData < sizeof(PIN_INFO)) {
      CMD_RETURN(ERROR_INSUFFICIENT_BUFFER, "cbData is too small");
    }

    if (p->dwVersion != PIN_INFO_CURRENT_VERSION) {
      CMD_RETURN(ERROR_REVISION_MISMATCH, "Invalid PIN_INFO version");
    }

    p->PinType = EmptyPinType;
    p->PinPurpose = PrimaryCardPin;
    p->dwChangePermission = PIN_SET_ALL_ROLES;
    p->dwUnblockPermission = PIN_SET_ALL_ROLES;
    p->PinCachePolicy.dwVersion = PIN_CACHE_POLICY_CURRENT_VERSION;
    p->PinCachePolicy.PinCachePolicyType = PinCacheNormal;
    p->PinCachePolicy.dwPinCachePolicyInfo = 0;

    *pdwDataLen = sizeof(PIN_INFO);

    CMD_RET_OK;
  } else if (wcscmp(wszProperty, CP_CARD_LIST_PINS) == 0) {
    // Card list of PINs property
    CMD_CHECK_DW_FLAGS;

    CMD_RET_UNIMPL;
  } else if (wcscmp(wszProperty, CP_CARD_AUTHENTICATED_STATE) == 0) {
    // Card authenticated state property
    CMD_CHECK_DW_FLAGS;

    CMD_RET_UNIMPL;
  } else if (wcscmp(wszProperty, CP_CARD_PIN_STRENGTH_VERIFY) == 0) {
    // Card PIN strength verify property
    CMD_RET_UNIMPL;
  } else if (wcscmp(wszProperty, CP_KEY_IMPORT_SUPPORT) == 0) {
    // Key import support property
    CMD_CHECK_DW_FLAGS;

    CMD_RET_UNIMPL;
  } else if (wcscmp(wszProperty, CP_ENUM_ALGORITHMS) == 0) {
    // Enum algorithms property
    CMD_RET_UNIMPL;
  } else if (wcscmp(wszProperty, CP_PADDING_SCHEMES) == 0) {
    // Padding schemes property
    CMD_RET_UNIMPL;
  } else if (wcscmp(wszProperty, CP_CHAINING_MODES) == 0) {
    // Chaining modes property
    CMD_CHECK_DW_FLAGS;

    CMD_RET_UNIMPL;
  }

  // Property not supported
  CMD_RETURN(SCARD_E_UNSUPPORTED_FEATURE, "Property not supported");
}

/*
 * Function: CardSetProperty
 *
 * Purpose: Set card properties.
 */
DWORD WINAPI CardSetProperty(__in PCARD_DATA pCardData, __in LPCWSTR wszProperty, __in_bcount(cbData) PBYTE pbData,
                             __in DWORD cbData, __in DWORD dwFlags) {
  CMD_DEBUG("CardSetProperty called with pCardData %p, wszProperty %S, pbData "
            "%p, cbData %d, dwFlags %x\n",
            pCardData, wszProperty, pbData, cbData, dwFlags);

  if (!pCardData || !wszProperty) {
    return ERROR_INVALID_PARAMETER;
  }

  CMD_RET_UNIMPL;
}

/*
 * Function: CardAuthenticatePin
 *
 * Purpose: Authenticate the PIN.
 */
DWORD WINAPI CardAuthenticatePin(__in PCARD_DATA pCardData, __in LPWSTR pwszUserId, __in_bcount(cbPin) PBYTE pbPin,
                                 __in DWORD cbPin, __out_opt PDWORD pcAttemptsRemaining) {
  CMD_DEBUG("CardAuthenticatePin called with pCardData %p, pwszUserId %S, "
            "pbPin %p, cbPin %d, pcAttemptsRemaining %p\n",
            pCardData, pwszUserId, pbPin, cbPin, pcAttemptsRemaining);

  if (!pCardData || !pwszUserId || !pbPin) {
    return ERROR_INVALID_PARAMETER;
  }

  CMD_RET_UNIMPL;
}

/*
 * Function: CardReadFile
 *
 * Purpose: Read a file from the card.
 */
DWORD WINAPI CardReadFile(__in PCARD_DATA pCardData, __in LPSTR pszDirectoryName, __in LPSTR pszFileName,
                          __in DWORD dwFlags, __deref_out_bcount_opt(*pcbData) PBYTE *ppbData, __out PDWORD pcbData) {
  CMD_DEBUG("CardReadFile called with pCardData %p, pszDirectoryName %s, pszFileName %s, dwFlags %x\n", pCardData,
            pszDirectoryName, pszFileName, dwFlags);

  if (pszDirectoryName == NULL) { // Root directory
    if (strcmp(pszFileName, szCACHE_FILE) == 0) {
      // TODO: Return cached data
      // now we return 6 bytes of zeros
      *ppbData = (PBYTE)g_pfnCspAlloc(6);
      if (*ppbData == NULL) {
        CMD_RETURN(SCARD_E_NO_MEMORY, "Failed to allocate memory");
      }
      memset(*ppbData, 0, 6);
      *pcbData = 6;
      CMD_RET_OK;
    }
  } else if (strcmp(pszDirectoryName, szBASE_CSP_DIR) == 0) {
    if (strcmp(pszFileName, szCONTAINER_MAP_FILE) == 0) {
      // TODO: Return container map

      *ppbData = (PBYTE)g_pfnCspAlloc(sizeof(CONTAINER_MAP_RECORD));
      if (*ppbData == NULL) {
        CMD_RETURN(SCARD_E_NO_MEMORY, "Failed to allocate memory");
      }

      PCONTAINER_MAP_RECORD p = (PCONTAINER_MAP_RECORD)*ppbData;
      memset(p, 0, sizeof(CONTAINER_MAP_RECORD));

      // Set the GUID for the container
      wcscpy(p->wszGuid, L"22b5b6d5-4495-52c7-c8g9-6g4b8g58de94");
      p->bFlags = CONTAINER_MAP_VALID_CONTAINER;
      p->wSigKeySizeBits = 2048;

      *pcbData = sizeof(CONTAINER_MAP_RECORD);
      CMD_RET_OK;
    } else if (strcmp(pszFileName, "ksc00") == 0) {
      // Return the hardcoded certificate for "ksc00"
      *ppbData = (PBYTE)g_pfnCspAlloc(687);
      if (*ppbData == NULL) {
        CMD_RETURN(SCARD_E_NO_MEMORY, "Failed to allocate memory");
      }
      const BYTE cert[] = {
          0x30, 0x82, 0x02, 0xae, 0x30, 0x82, 0x01, 0x96, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x08, 0x7f, 0xaf, 0x86,
          0xa8, 0x38, 0xcf, 0x87, 0x8c, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b,
          0x05, 0x00, 0x30, 0x0d, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x02, 0x43, 0x41, 0x30,
          0x1e, 0x17, 0x0d, 0x32, 0x34, 0x31, 0x31, 0x31, 0x38, 0x31, 0x33, 0x30, 0x32, 0x30, 0x30, 0x5a, 0x17, 0x0d,
          0x32, 0x35, 0x31, 0x31, 0x31, 0x38, 0x31, 0x32, 0x35, 0x35, 0x30, 0x30, 0x5a, 0x30, 0x12, 0x31, 0x10, 0x30,
          0x0e, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x07, 0x72, 0x73, 0x61, 0x32, 0x30, 0x34, 0x38, 0x30, 0x82, 0x01,
          0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82,
          0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xba, 0x80, 0x55, 0x39, 0x42, 0x0b,
          0x63, 0x12, 0x77, 0x86, 0xcd, 0x25, 0xbc, 0xbb, 0xd9, 0xcb, 0x10, 0xfe, 0xee, 0xa7, 0xc5, 0x6d, 0x61, 0xf4,
          0x22, 0x41, 0xe0, 0xeb, 0xf3, 0xa3, 0x38, 0xd3, 0xba, 0x6c, 0x8a, 0x02, 0x6a, 0x27, 0xc6, 0x6a, 0x20, 0xa4,
          0xe8, 0xf3, 0x45, 0x3e, 0xa2, 0xc6, 0xa3, 0x6b, 0x7d, 0xf4, 0xa1, 0x88, 0x3f, 0xc1, 0x41, 0xb8, 0xf8, 0xce,
          0xe7, 0x80, 0xd9, 0xb9, 0x3a, 0x5f, 0x91, 0x1a, 0xbb, 0x57, 0xce, 0x59, 0x19, 0xf9, 0x26, 0x20, 0xee, 0xba,
          0x0c, 0xa4, 0xf3, 0xd2, 0xd3, 0x3f, 0x40, 0xe9, 0x6e, 0x52, 0x22, 0x81, 0xc4, 0x6f, 0x25, 0x6e, 0x16, 0x73,
          0x3f, 0x29, 0x5e, 0xe8, 0x47, 0x93, 0xa3, 0xe6, 0xcb, 0xe5, 0xb4, 0x61, 0x1e, 0x80, 0xf2, 0x6f, 0xc7, 0x9b,
          0xd9, 0x85, 0xf6, 0x3d, 0x5d, 0x00, 0x82, 0x16, 0x87, 0x61, 0x2d, 0xb8, 0x4f, 0x08, 0xb2, 0xe4, 0xf5, 0x93,
          0x55, 0x53, 0xea, 0x7e, 0x01, 0xa6, 0x66, 0xf1, 0xfc, 0xfd, 0x7f, 0xeb, 0xd3, 0x2d, 0x42, 0x42, 0xd9, 0x19,
          0x3b, 0x25, 0x3c, 0x72, 0x3e, 0xed, 0x26, 0x12, 0x33, 0x00, 0x86, 0x02, 0xad, 0x1e, 0xd2, 0xc5, 0xc8, 0x78,
          0xe0, 0xa7, 0xd7, 0x8d, 0x47, 0x16, 0xe1, 0xa3, 0xde, 0x80, 0xaf, 0x2b, 0xd6, 0xea, 0xa4, 0xaf, 0xd4, 0x22,
          0x1d, 0x47, 0x0c, 0x80, 0xbb, 0x64, 0xd6, 0x31, 0x67, 0x86, 0xde, 0x46, 0xb2, 0x75, 0xab, 0x69, 0xcc, 0xd7,
          0x54, 0x14, 0xfc, 0xf4, 0x8f, 0xdf, 0x24, 0x59, 0x80, 0x91, 0x77, 0x81, 0xa1, 0x25, 0xf2, 0xe5, 0x1d, 0xd2,
          0x32, 0x0d, 0x37, 0x87, 0xcb, 0x28, 0x53, 0x23, 0xf2, 0xfb, 0x35, 0x68, 0xd3, 0x27, 0xdb, 0x5a, 0xb1, 0x55,
          0xfd, 0x7d, 0x3c, 0xfd, 0x58, 0x37, 0x9e, 0x07, 0xa7, 0xe7, 0xf5, 0x3e, 0xdf, 0xe6, 0x10, 0xdb, 0x02, 0x03,
          0x01, 0x00, 0x01, 0xa3, 0x0d, 0x30, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x02, 0x30, 0x00,
          0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01,
          0x01, 0x00, 0x7a, 0x7e, 0x32, 0x69, 0xf9, 0x49, 0xff, 0x7f, 0x2c, 0xa9, 0x14, 0x15, 0x50, 0x85, 0x9a, 0x89,
          0x0f, 0x48, 0x54, 0x0a, 0xfb, 0xb6, 0xb9, 0xa3, 0x01, 0xe4, 0xdb, 0x8e, 0x98, 0x6c, 0xc2, 0x2e, 0xc8, 0x0a,
          0x6a, 0x19, 0xcb, 0xe2, 0xa5, 0x13, 0x3d, 0xf5, 0xe9, 0xa1, 0x5e, 0xec, 0x9f, 0xbb, 0xf0, 0xfc, 0x6f, 0x32,
          0x47, 0x9c, 0xf8, 0x7a, 0xd4, 0xd9, 0xec, 0x44, 0x23, 0xd4, 0x73, 0x41, 0x89, 0x35, 0xe8, 0xc2, 0x28, 0xea,
          0x16, 0x25, 0x3a, 0x2a, 0x76, 0xd9, 0x35, 0xad, 0xf7, 0xf7, 0xef, 0x55, 0x6e, 0x03, 0xb3, 0x16, 0x62, 0x8d,
          0x80, 0x7b, 0xce, 0x6c, 0xac, 0xbc, 0xba, 0x9f, 0x7a, 0x6c, 0x7e, 0x11, 0x00, 0x80, 0xd6, 0x71, 0x13, 0xb3,
          0x73, 0x50, 0x49, 0x29, 0x9e, 0x5f, 0x02, 0x24, 0xe7, 0xd9, 0x77, 0xc5, 0xf6, 0x41, 0xa0, 0x0c, 0xb2, 0xfd,
          0xde, 0x33, 0xf5, 0x99, 0xbd, 0x55, 0xda, 0x2e, 0x32, 0x8b, 0x11, 0x6f, 0xba, 0xb4, 0xcf, 0x56, 0xc2, 0xcb,
          0xbf, 0x7e, 0x41, 0x02, 0x42, 0x39, 0xe7, 0x8f, 0xdb, 0x80, 0x2e, 0x33, 0xa2, 0x45, 0x3f, 0x6d, 0x2a, 0xf3,
          0xb7, 0xd0, 0x1c, 0xd5, 0x71, 0x9e, 0x27, 0xa5, 0x5a, 0x30, 0x1f, 0x7f, 0x31, 0x6f, 0x78, 0xff, 0xa6, 0x1e,
          0x58, 0x63, 0x99, 0x51, 0x02, 0xc0, 0x6c, 0x0e, 0x92, 0xa0, 0xe8, 0x9c, 0xc4, 0xe1, 0xff, 0x87, 0x1d, 0xd4,
          0xa9, 0x98, 0x37, 0xa1, 0x26, 0xac, 0x5b, 0x23, 0xbb, 0xb2, 0xe8, 0xf6, 0x2f, 0xa5, 0xe2, 0x56, 0xe0, 0xef,
          0xf2, 0x72, 0x02, 0x4f, 0x4f, 0x3d, 0x5a, 0xa0, 0xf4, 0xde, 0xc0, 0x98, 0x79, 0x31, 0x02, 0x53, 0x94, 0x6b,
          0x3f, 0x21, 0xf6, 0xbc, 0x72, 0x16, 0x17, 0x95, 0x2b, 0x2f, 0xe8, 0xe1, 0xb1, 0xb6, 0x13, 0x1b, 0x5d, 0x2b,
          0x61, 0x1b, 0xc2, 0x14, 0x67, 0x06};
      memcpy(*ppbData, cert, sizeof(cert));
      *pcbData = sizeof(cert);
      CMD_RET_OK;
    }
  }

  CMD_RET_UNIMPL;
}

/*
 * Function: CardGetFileInfo
 *
 * Purpose: Get information about a file on the card.
 */
DWORD WINAPI CardGetFileInfo(__in PCARD_DATA pCardData, __in LPSTR pszDirectoryName, __in LPSTR pszFileName,
                             __in PCARD_FILE_INFO pCardFileInfo) {
  CMD_DEBUG("CardGetFileInfo called with pCardData %p, pszDirectoryName %s, "
            "pszFileName %s, pCardFileInfo %p\n",
            pCardData, pszDirectoryName, pszFileName, pCardFileInfo);

  if (!pCardData || !pszDirectoryName || !pszFileName || !pCardFileInfo) {
    return ERROR_INVALID_PARAMETER;
  }

  CMD_RET_UNIMPL;
}

/*
 * Function: CardEnumFiles
 *
 * Purpose: Enumerate files in a directory on the card.
 */
DWORD WINAPI CardEnumFiles(__in PCARD_DATA pCardData, __in_opt LPSTR pszDirectoryName,
                           __deref_out_ecount(*pdwcbFileName) LPSTR *pmszFileNames, __out LPDWORD pdwcbFileName,
                           __in DWORD dwFlags) {
  CMD_DEBUG("CardEnumFiles called with pCardData %p, pszDirectoryName %s, "
            "pmszFileNames %p, pdwcbFileName %p, dwFlags %x\n",
            pCardData, pszDirectoryName, pmszFileNames, pdwcbFileName, dwFlags);

  if (!pCardData || !pdwcbFileName) {
    return ERROR_INVALID_PARAMETER;
  }

  CMD_RET_UNIMPL;
}

/*
 * Function: CardQueryFreeSpace
 *
 * Purpose: Query the free space on the card.
 */
DWORD WINAPI CardQueryFreeSpace(__in PCARD_DATA pCardData, __in DWORD dwFlags,
                                __inout PCARD_FREE_SPACE_INFO pCardFreeSpaceInfo) {
  CMD_DEBUG("CardQueryFreeSpace called with pCardData %p, dwFlags %x, "
            "pCardFreeSpaceInfo %p\n",
            pCardData, dwFlags, pCardFreeSpaceInfo);

  if (!pCardData || !pCardFreeSpaceInfo) {
    return ERROR_INVALID_PARAMETER;
  }

  CMD_RET_UNIMPL;
}
/*
 * Function: CardQueryCapabilities
 *
 * Purpose: Query the capabilities of the card.
 */
DWORD WINAPI CardQueryCapabilities(__in PCARD_DATA pCardData, __inout PCARD_CAPABILITIES pCardCapabilities) {
  CMD_DEBUG("CardQueryCapabilities called with pCardData %p, pCardCapabilities %p\n", pCardData, pCardCapabilities);

  if (!pCardData || !pCardCapabilities) {
    return ERROR_INVALID_PARAMETER;
  }

  if (pCardCapabilities->dwVersion != CARD_CAPABILITIES_CURRENT_VERSION) {
    return ERROR_REVISION_MISMATCH;
  }

  // Set capabilities
  pCardCapabilities->fCertificateCompression = FALSE;
  pCardCapabilities->fKeyGen = TRUE;

  CMD_RET_OK;
}

typedef struct {
  PUBLICKEYSTRUC publickeystruc;
  RSAPUBKEY rsapubkey;
} PUBRSAKEYSTRUCT_BASE;

/*
 * Function: CardGetContainerInfo
 *
 * Purpose: Get information about a key container on the card.
 */
DWORD WINAPI CardGetContainerInfo(__in PCARD_DATA pCardData, __in BYTE bContainerIndex, __in DWORD dwFlags,
                                  __inout PCONTAINER_INFO pContainerInfo) {
  CMD_DEBUG("CardGetContainerInfo called with pCardData %p, bContainerIndex %d, dwFlags %x, dwVersion %d\n", pCardData,
            bContainerIndex, dwFlags, pContainerInfo->dwVersion);

  if (!pCardData || !pContainerInfo) {
    CMD_RETURN(SCARD_E_INVALID_PARAMETER, "Invalid parameter");
  }

  if (pContainerInfo->dwVersion > CONTAINER_INFO_CURRENT_VERSION) {
    CMD_RETURN(SCARD_E_INVALID_PARAMETER, "Invalid container info version");
  }

  if (bContainerIndex != 0) {
    CMD_RETURN(SCARD_E_NO_KEY_CONTAINER, "Invalid container index");
  }

  // Create a properly formatted RSA public key structure
  PUBRSAKEYSTRUCT_BASE keyHeader;
  DWORD modulusSize = 256; // 2048 bits = 256 bytes
  DWORD exponentSize = 4;  // Standard RSA exponent size
  DWORD totalSize = sizeof(PUBRSAKEYSTRUCT_BASE) + modulusSize;

  // Allocate memory for the complete key structure
  pContainerInfo->cbSigPublicKey = totalSize;
  pContainerInfo->pbSigPublicKey = (PBYTE)g_pfnCspAlloc(totalSize);
  if (pContainerInfo->pbSigPublicKey == NULL) {
    CMD_RETURN(SCARD_E_NO_MEMORY, "Failed to allocate memory for signature key");
  }

  // Initialize the key header
  keyHeader.publickeystruc.bType = PUBLICKEYBLOB;
  keyHeader.publickeystruc.bVersion = CUR_BLOB_VERSION;
  keyHeader.publickeystruc.reserved = 0;
  keyHeader.publickeystruc.aiKeyAlg = CALG_RSA_SIGN;

  keyHeader.rsapubkey.magic = 0x31415352; // RSA1 in little-endian
  keyHeader.rsapubkey.bitlen = 2048;      // Key size in bits
  keyHeader.rsapubkey.pubexp = 65537;     // Standard RSA exponent (0x10001)

  // Copy the key header to the allocated memory
  memcpy(pContainerInfo->pbSigPublicKey, &keyHeader, sizeof(PUBRSAKEYSTRUCT_BASE));

  BYTE modulus[256] = {
      // This is the raw modulus extracted from the ASN.1 structure
      0xba, 0x80, 0x55, 0x39, 0x42, 0x0b, 0x63, 0x12, 0x77, 0x86, 0xcd, 0x25, 0xbc, 0xbb, 0xd9, 0xcb, 0x10, 0xfe, 0xee,
      0xa7, 0xc5, 0x6d, 0x61, 0xf4, 0x22, 0x41, 0xe0, 0xeb, 0xf3, 0xa3, 0x38, 0xd3, 0xba, 0x6c, 0x8a, 0x02, 0x6a, 0x27,
      0xc6, 0x6a, 0x20, 0xa4, 0xe8, 0xf3, 0x45, 0x3e, 0xa2, 0xc6, 0xa3, 0x6b, 0x7d, 0xf4, 0xa1, 0x88, 0x3f, 0xc1, 0x41,
      0xb8, 0xf8, 0xce, 0xe7, 0x80, 0xd9, 0xb9, 0x3a, 0x5f, 0x91, 0x1a, 0xbb, 0x57, 0xce, 0x59, 0x19, 0xf9, 0x26, 0x20,
      0xee, 0xba, 0x0c, 0xa4, 0xf3, 0xd2, 0xd3, 0x3f, 0x40, 0xe9, 0x6e, 0x52, 0x22, 0x81, 0xc4, 0x6f, 0x25, 0x6e, 0x16,
      0x73, 0x3f, 0x29, 0x5e, 0xe8, 0x47, 0x93, 0xa3, 0xe6, 0xcb, 0xe5, 0xb4, 0x61, 0x1e, 0x80, 0xf2, 0x6f, 0xc7, 0x9b,
      0xd9, 0x85, 0xf6, 0x3d, 0x5d, 0x00, 0x82, 0x16, 0x87, 0x61, 0x2d, 0xb8, 0x4f, 0x08, 0xb2, 0xe4, 0xf5, 0x93, 0x55,
      0x53, 0xea, 0x7e, 0x01, 0xa6, 0x66, 0xf1, 0xfc, 0xfd, 0x7f, 0xeb, 0xd3, 0x2d, 0x42, 0x42, 0xd9, 0x19, 0x3b, 0x25,
      0x3c, 0x72, 0x3e, 0xed, 0x26, 0x12, 0x33, 0x00, 0x86, 0x02, 0xad, 0x1e, 0xd2, 0xc5, 0xc8, 0x78, 0xe0, 0xa7, 0xd7,
      0x8d, 0x47, 0x16, 0xe1, 0xa3, 0xde, 0x80, 0xaf, 0x2b, 0xd6, 0xea, 0xa4, 0xaf, 0xd4, 0x22, 0x1d, 0x47, 0x0c, 0x80,
      0xbb, 0x64, 0xd6, 0x31, 0x67, 0x86, 0xde, 0x46, 0xb2, 0x75, 0xab, 0x69, 0xcc, 0xd7, 0x54, 0x14, 0xfc, 0xf4, 0x8f,
      0xdf, 0x24, 0x59, 0x80, 0x91, 0x77, 0x81, 0xa1, 0x25, 0xf2, 0xe5, 0x1d, 0xd2, 0x32, 0x0d, 0x37, 0x87, 0xcb, 0x28,
      0x53, 0x23, 0xf2, 0xfb, 0x35, 0x68, 0xd3, 0x27, 0xdb, 0x5a, 0xb1, 0x55, 0xfd, 0x7d, 0x3c, 0xfd, 0x58, 0x37, 0x9e,
      0x07, 0xa7, 0xe7, 0xf5, 0x3e, 0xdf, 0xe6, 0x10, 0xdb};

  // Copy the modulus after the header
  memcpy(pContainerInfo->pbSigPublicKey + sizeof(PUBRSAKEYSTRUCT_BASE), modulus, modulusSize);

  // No key exchange key in this implementation
  pContainerInfo->cbKeyExPublicKey = 0;
  pContainerInfo->pbKeyExPublicKey = NULL;

  CMD_RET_OK;
}

/*
 * Function: CardSignData
 *
 * Purpose: Sign data using a key on the card.
 */
DWORD WINAPI CardSignData(__in PCARD_DATA pCardData, __in PCARD_SIGNING_INFO pCardSigningInfo) {
  CMD_DEBUG("CardSignData called with pCardData %p, pCardSigningInfo %p\n", pCardData, pCardSigningInfo);

  if (!pCardData || !pCardSigningInfo) {
    return ERROR_INVALID_PARAMETER;
  }

  CMD_RET_UNIMPL;
}

/*
 * Function: CardQueryKeySizes
 *
 * Purpose: Query the supported key sizes for a given algorithm.
 */
DWORD WINAPI CardQueryKeySizes(__in PCARD_DATA pCardData, __in DWORD dwKeySpec, __in DWORD dwFlags,
                               __inout PCARD_KEY_SIZES pKeySizes) {
  CMD_DEBUG("CardQueryKeySizes called with pCardData %p, dwKeySpec %x, dwFlags "
            "%x, pKeySizes %p\n",
            pCardData, dwKeySpec, dwFlags, pKeySizes);

  if (!pCardData || !pKeySizes) {
    return ERROR_INVALID_PARAMETER;
  }

  CMD_RET_UNIMPL;
}

/*
 * Function: CardAuthenticateEx
 *
 * Purpose: Authenticate to the card with extended parameters.
 */
DWORD WINAPI CardAuthenticateEx(__in PCARD_DATA pCardData, __in PIN_ID PinId, __in DWORD dwFlags,
                                __in_bcount(cbPinData) PBYTE pbPinData, __in DWORD cbPinData,
                                __deref_opt_out_bcount(*pcbSessionPin) PBYTE *ppbSessionPin,
                                __out_opt PDWORD pcbSessionPin, __out_opt PDWORD pcAttemptsRemaining) {
  CMD_DEBUG("CardAuthenticateEx called with pCardData %p, PinId %d, dwFlags "
            "%x, pbPinData %p, cbPinData %d\n",
            pCardData, PinId, dwFlags, pbPinData, cbPinData);

  if (!pCardData) {
    return ERROR_INVALID_PARAMETER;
  }

  CMD_RET_UNIMPL;
}

/*
 * Function: CardDeauthenticateEx
 *
 * Purpose: Deauthenticate from the card with extended parameters.
 */
DWORD WINAPI CardDeauthenticateEx(__in PCARD_DATA pCardData, __in PIN_SET PinId, __in DWORD dwFlags) {
  CMD_DEBUG("CardDeauthenticateEx called with pCardData %p, PinId %d, dwFlags %x\n", pCardData, PinId, dwFlags);

  if (!pCardData) {
    return ERROR_INVALID_PARAMETER;
  }

  CMD_RET_UNIMPL;
}

/*
 * Function: CardGetContainerProperty
 *
 * Purpose: Get a property of a key container on the card.
 */
DWORD WINAPI CardGetContainerProperty(__in PCARD_DATA pCardData, __in BYTE bContainerIndex, __in LPCWSTR wszProperty,
                                      __out_bcount_part_opt(cbData, *pdwDataLen) PBYTE pbData, __in DWORD cbData,
                                      __out PDWORD pdwDataLen, __in DWORD dwFlags) {
  CMD_DEBUG("CardGetContainerProperty called with pCardData %p, bContainerIndex %d, wszProperty %S, dwFlags %x\n",
            pCardData, bContainerIndex, wszProperty, dwFlags);

  if (dwFlags != 0) {
    CMD_RETURN(SCARD_E_INVALID_PARAMETER, "Invalid dwFlags");
  }

  if (wcscmp(wszProperty, CCP_PIN_IDENTIFIER) == 0) {
    // TODO
    *pbData = ROLE_EVERYONE;
    *pdwDataLen = sizeof(PIN_ID);
    CMD_RET_OK;
  }

  CMD_RETURN(SCARD_E_INVALID_PARAMETER, "Invalid property");
}
